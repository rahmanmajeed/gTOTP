import crypto from "crypto";
import base32 from "hi-base32";

/**
 * @digest {options}
 */

export const digest = (options: any) => {
  //unpack options
  let secret = options.secret;
  let counter = options.counter;
  let encoding = options.encoding || 'ascii';
  let algorithm = (options.algorithm || 'sha1').toLowerCase();

  //secret key buffer size.
  let _secret_buffer_size;

  //convert secret to Buffer...
  if(!Buffer.isBuffer(secret)){
    if (encoding === 'base32') { secret = base32.decode(secret); } 
    secret = Buffer.from(secret, encoding)
  }

  switch (algorithm) {
    case 'sha1':
      _secret_buffer_size = 20; // 20bytes
      break;
    case 'sha256':
      _secret_buffer_size = 32; // 32bytes
    case 'sha512':
      _secret_buffer_size =  64; // 64bytes
    default:
      console.warn('given algorithm doesn\'t support by this package.')
      break;
  }

};

/**
 * @generateSecretASCII
 * @params {integer}{length} the length of the key.
 * @params {symbols}
 * @return {string} the generated key.
 */

export const generateSecretASCII = (length: number, symbols:boolean) => {
    const bytes = crypto.randomBytes(length || 32);
    let set = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz';
    let output = '';

    //set symbols to output
    if(symbols){
      set += '!@#$%^&*()<>?/[]{},.:;';
    }

    // for (let i = 0; i < bytes.length; i++) {
    //   output += set[Math.floor(bytes[i] / 255.0 * (set.length - 1))];
    // }
    for (const byte of bytes) {
      output += set[Math.floor(byte / 255.0 * (set.length - 1))];
    }
    
    return output;
}

/**
 * Generate a counter-based one-time token. To generate HOTP Specify the key and counter, and
 * receive the one-time password for that counter position as a string. You can
 * also specify a token length, as well as the encoding (ASCII, hexadecimal, or
 * base32) and the hashing algorithm to use (SHA1, SHA256, SHA512).
 *
 * @param {Object} options
 * @param {String} options.secret Shared secret key
 * @param {Integer} options.counter Counter value
 * @param {Buffer} [options.digest] Digest, automatically generated by default
 * @param {Integer} [options.digits=6] The number of digits for the one-time
 *   passcode.
 * @param {String} [options.encoding="ascii"] Key encoding (ascii, hex,
 *   base32, base64).
 * @param {String} [options.algorithm="sha1"] Hash algorithm (sha1, sha256,
 *   sha512).
 * @param {String} [options.key] (DEPRECATED. Use `secret` instead.)
 *   Shared secret key
 * @param {Integer} [options.length=6] (DEPRECATED. Use `digits` instead.) The
 *   number of digits for the one-time passcode.
 * @return {String} The one-time passcode.
 */

export const generateHOTP = (options:any) => {
  //verify options for secret & counter.
  let secret = options.secret;
  let counter = options.counter;
  let key = options.key;
}

/**
 * @generate {secret}
 * @params {options}
 * @return {secret}
 */

export const generateSecret = (options: any) => {
  //options

  if (!options) options = {};
  let length = options.length || 32;
  let name = options.name || "SecretKey";
  let symbols = true;

  // turn off symbols only when explicity told to.
  if (options.symbols !== undefined && options.symbols === false) {
    symbols = false;
  }

  //generate base32 secret...
  const key = generateSecretASCII(length, symbols)

  const secretKey:any = {
     ascii: key,
     hex: Buffer.from(key, 'ascii').toString('hex'),
     base32: base32.encode(Buffer.from(key)).toString().replace(/=/g, '')
  }
  return secretKey;
};

console.log(generateSecret({ length: 20 }));
